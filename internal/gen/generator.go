package gen

import (
	"bufio"
	"errors"
	"fmt"
	"math/rand/v2"
	"os"
	"strconv"
)

var errStop = errors.New("stop")

// IPsFile generates random IPv4 lines (with duplicates).
func IPsFile(targetBytes int64) (string, error) {
	if targetBytes <= 0 {
		return "", errors.New("targetBytes must be > 0")
	}
	if targetBytes < 8 { // "0.0.0.0\n"
		return "", errors.New("targetBytes too small to hold even a single IP line")
	}

	f, w, tmpPath, err := openTempWriter()
	if err != nil {
		return "", err
	}
	defer func() {
		_ = f.Close()
		_ = os.Remove(tmpPath)
	}()

	u := newUniqBitset()    // exact unique counter (2^32 addresses)
	r := newReuseRing(1024) // duplicates injector ring

	stats := genLoop(w, targetBytes, u, r)
	if stats.err != nil && !errors.Is(stats.err, errStop) {
		return "", stats.err
	}
	if err := w.Flush(); err != nil {
		return "", err
	}
	if err := f.Close(); err != nil {
		return "", err
	}
	final := finalName(stats.written, stats.total, stats.unique)
	if err := os.Rename(tmpPath, final); err != nil {
		return "", err
	}
	return final, nil
}

// openTempWriter creates a temp file in CWD and a buffered writer.
func openTempWriter() (*os.File, *bufio.Writer, string, error) {
	const bufSize = 16 << 20
	f, err := os.CreateTemp(".", "ips_autogenerated_mock_*.tmp")
	if err != nil {
		return nil, nil, "", err
	}
	return f, bufio.NewWriterSize(f, bufSize), f.Name(), nil
}

// genLoop mixes random IPs with duplicates until budget is reached.
// It returns total lines, unique lines, bytes written, and a terminal error (errStop on normal cutoff).
func genLoop(w *bufio.Writer, budget int64, u *uniqBitset, r *reuseRing) (s stats) {
	const (
		dupChance  = 0.42
		maxLineLen = 16 // "255.255.255.255\n"
	)
	line := make([]byte, 0, maxLineLen)

	emit := func(a, b, c, d byte) error {
		line = line[:0]
		line = strconv.AppendInt(line, int64(a), 10)
		line = append(line, '.')
		line = strconv.AppendInt(line, int64(b), 10)
		line = append(line, '.')
		line = strconv.AppendInt(line, int64(c), 10)
		line = append(line, '.')
		line = strconv.AppendInt(line, int64(d), 10)
		line = append(line, '\n')

		if s.written+int64(len(line)) > budget {
			return errStop
		}
		if _, err := w.Write(line); err != nil {
			return err
		}
		s.written += int64(len(line))
		s.total++
		if u.set(a, b, c, d) {
			s.unique++
		}
		r.put(a, b, c, d)
		return nil
	}

	for {
		// duplicate path
		if r.len() > 0 && rand.Float64() < dupChance {
			a, b, c, d := r.pick()
			if err := emit(a, b, c, d); err != nil {
				s.err = err
				return s
			}
			continue
		}
		// fresh random IPv4 from a single RNG draw
		x := rand.Uint64()
		a := byte(x)
		b := byte(x >> 8)
		c := byte(x >> 16)
		d := byte(x >> 24)

		if err := emit(a, b, c, d); err != nil {
			s.err = err
			return s
		}
	}
}

type stats struct {
	total   uint64
	unique  uint64
	written int64
	err     error
}

// 2^32 coverage
type uniqBitset struct {
	words []uint64
}

func newUniqBitset() *uniqBitset {
	const words = 1 << 26
	return &uniqBitset{words: make([]uint64, words)}
}

func (u *uniqBitset) set(a, b, c, d byte) bool {
	ip := (uint32(a) << 24) | (uint32(b) << 16) | (uint32(c) << 8) | uint32(d)
	idx := ip >> 6
	bit := uint64(1) << (ip & 63)
	w := u.words[idx]
	if w&bit != 0 {
		return false
	}
	u.words[idx] = w | bit
	return true
}

// duplicate injector ring
type reuseRing struct {
	buf   [][4]byte
	w     int
	count int
}

func newReuseRing(capacity int) *reuseRing {
	if capacity <= 0 {
		capacity = 1
	}
	return &reuseRing{buf: make([][4]byte, capacity)}
}

func (r *reuseRing) put(a, b, c, d byte) {
	r.buf[r.w%len(r.buf)] = [4]byte{a, b, c, d}
	r.w++
	if r.count < len(r.buf) {
		r.count++
	}
}

func (r *reuseRing) len() int { return r.count }

func (r *reuseRing) pick() (byte, byte, byte, byte) {
	i := rand.IntN(r.count)
	ip := r.buf[i]
	return ip[0], ip[1], ip[2], ip[3]
}

// etc
func finalName(bytes int64, total, unique uint64) string {
	return fmt.Sprintf(
		"ips_autogenerated_mock_%s_total-%d_unique-%d.txt",
		fmtBytes(bytes), total, unique,
	)
}

// fmtBytes prints bytes in human-readable style, e.g. 1Gb, 10Gb and so on.
func fmtBytes(n int64) string {
	type unit struct {
		name string
		size int64
	}
	units := []unit{
		{"TiB", 1 << 40},
		{"GiB", 1 << 30},
		{"MiB", 1 << 20},
		{"KiB", 1 << 10},
	}
	if n < 1024 {
		return fmt.Sprintf("%dB", n)
	}
	for _, u := range units {
		if n >= u.size {
			val := float64(n) / float64(u.size)
			return fmt.Sprintf("%s%s", trim2(val), u.name)
		}
	}
	return fmt.Sprintf("%dB", n)
}

// trim2 formats with up to 2 decimals, trimming trailing zeros and dot.
func trim2(f float64) string {
	s := fmt.Sprintf("%.2f", f)
	// remove trailing zeros and optional dot
	for len(s) > 0 && s[len(s)-1] == '0' {
		s = s[:len(s)-1]
	}
	if len(s) > 0 && s[len(s)-1] == '.' {
		s = s[:len(s)-1]
	}
	return s
}
